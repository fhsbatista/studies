# Criando imagens customizadas
## Cuidados para imagens em produçã
 - Buscar uma imagem com o menor tamanho possível, pois:
  - diminui espaço em disco
  - mais segura, pois tem menos dependências

## Dockerfile
É uma receita pra criar uma imagem.
Pra criar uma imagem, sempre iremos nos basear em alguma imagem já existente (ou várias).

exemplo:
```
FROM node:latest # estamos no baseando numa imagem de node. Obs: usar o "latest" não é recomendando. 

WORKDIR /app # navega para a pasta /app

COPY . . # copia tudo o que tem na pasta em que está o Dockerfile para a pasta atual do workdir (que é /app)

CMD ["node", "index.js"] # executa o comando "node index.js"


```

## Build da imagem
Para gerar a imagem a partir do Dockerfile, precisamos fazer o build, pra isso temos o comando `build`.

ex:
`docker build -t fhsbatista/docker-node-example:latest .`.
Acima, coloquei um namespace, que poderia ser o nome do usuário no dockerhub. E o latest seria a tag. No final precisamos indicar a localizacao do dockerfile, por isso o ".". Isso pode ser substituido pelo diretorio caso o dockerfile esteja num diretorio diferente.

Obs: antes do build ser feito, o docker irá baixar a imagem de cada layer que sua imagem precisa.

Obs2: A imagem, após gerada, fica apenas no seu computador. Para consultá-la, você pode usar o comando `docker images`.

## Rodando a imagem
Basta usar o comando `run`.

## ARG
É uma maneira de criar "variáveis" no Dockerfile.
Ex: Abaixo, veja que é usado o NODE_VERSION para definir a versão do node, em vez de usar `latest` hardcoded.

```
ARG NODE_VERSION=21.1.0
FROM NODE:${NODE_VERSION}
```

A grande vantagem de usar isso, é que esses args podem ser passados no momento de buildar a imagem.
Ex:
`docker build --build-arg NODE_VERSION=21.1.0 -t fhsbatista/docker-node-example:latest`

Importante: O ARG só está disponível no momento do build da imagem. Portanto, não dá pra usar esses valores em runtime.

## ENV
É parecido com ARG, porém, esse fica disponível em runtime. Por conta disso, pode ser usado como uma espécie de variável de ambiente que a aplicação pode consumir enquanto é executada. Ex: definir o número da porta em que a aplicação rodará.

```
#Dockerfile
ENV PORT=3001
ENV MESSAGE="Hello docker"

#index.js
const port = process.env.PORT || 3000;

const message = process.env.MESSAGE || "HELLO WORLD!";

app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
})
```

Essas ENV podem ser passadas ao criar e executar um container.
Ex:
`docker run -p 3001:3001 -e MESSAGE="Hello Friend" fhsbatista/docker-node-example`


## Segurança e usuários não root
### Usuário padrão do container
No ambiente de produção é muito importante não deixarmos o usuário root como o padrao do container. Para evitar isso, podemos configurar um novo usuário no Dockerfile e ativar esse usuário como o padrao do container.

ex:
```
RUN useradd -m mynode #cria um novo usuário
USER mynode #coloca esse usuário como o padrao do container.
```

Dessa forma, quando abrirmos o bash, o usuário novo será usado. E assim, não vamos conseguir executar comandos como administrador.

Uma outra maneira de tirar o acesso do root, sem criar um novo usuário, é usar um id que define as permissoes.

ex:
```
USER 1001
```

Usando essa abordagem, o usuário usado ao executar o bash será o "I have no name".

## Healthcheck
O docker dá uma ferramenta para configurarmos chamadas de healthcheck e que podemos declarar diretamente no Dockerfile.
Caso as chamadas não satisfaçam as condições que definimos para considerar o container como "healthy", o docker já avisa isso na coluna "status"  do `docker ps`.

ex:
```
HEALTHCHECK --interval=10s --timeout=5s --start-period=5s --retries=3 \
  CMD ["curl", "-f", "http://localhost:3001"]
```

## Cache para diminuir tempo de build e dockerignore
O docker, ao fazer o build, vai passar linhar por linha do dockerfile.
Ao executar cada linha, ele deixa o resultado dela em um cache.
Assim, em um próximo build, caso essa linha não tenha mudado, é usado o cache em vez de executar a tarefa novamente.
O ponto de atenção é: quando uma linha mudou, os caches das linhas debaixo sao invalidados, ou seja, dali pra frente o docker irá executar tudo novamente.

Entender isso é util para nao executar tarefas pesadas, como um "npm install".
Por exemplo, para evitar a execução do npm install, no dockerfile podemos, antes de copiar os arquivos do nosso source code para a imagem, podemos copiar somente o package.json e o package-lock.json e dar um "npm install". Depois disso copiamos o resto dos arquivos. Dessa forma, nós cacheamos a node_modules. Se nao fizermos isso, ou seja, só copiar todos os arquivos mesmo, meio que em toda geração de imagem o npm install seria executado novamente, pois, em teoria, se estamos gerando a imagem novamente é porque alguma coisa no nosso source code mudou. O ponto é que talvez essa coisa não necessariamente foi uma alteração no package.json, e nesse caso o npm install não seria necessário, mas seria executado pois estamos copiando o source code itneiro de uma só vez.

Obs: ao gerar o build, é demonstrado no console todas as layers que foram geradas. Quando uma layer está cacheada, aparece [CACHED].

Um exemplo ficaria assim:

```
ARG NODE_VERSION=latest
FROM node:${NODE_VERSION}

ENV PORT=3001
ENV MESSAGE="Hello docker."

# RUN useradd -m mynode
# USER mynode

USER 1001

WORKDIR /app

COPY package*.json ./

RUN npm install

COPY . . #Se nao houver alterações no package.json, teoricamente daqui pra cima nada será executado pois será usado cache apenas.

HEALTHCHECK --interval=10s --timeout=5s --start-period=5s --retries=3 \
  CMD ["curl", "-f", "http://localhost:3001"]

CMD ["node", "index.js"]
```

Mas claro, temos um detalhe aqui. Ao fazermos o `COPY . .`, o node_modules seria copiado também, o que estaria errado pois ao buildar a imagem nós já rodamos o npm install, o que vai gerar o node_modules. Pra evitar isso, podemos colocar essa pasta no arquivo .dockerignore.

Ex de .dockerignore

```
#.dockerignore
node_modules
npm-debug.log
```
