# Criando imagens customizadas
## Cuidados para imagens em produçã
 - Buscar uma imagem com o menor tamanho possível, pois:
  - diminui espaço em disco
  - mais segura, pois tem menos dependências

## Dockerfile
É uma receita pra criar uma imagem.
Pra criar uma imagem, sempre iremos nos basear em alguma imagem já existente (ou várias).

exemplo:
```
FROM node:latest # estamos no baseando numa imagem de node. Obs: usar o "latest" não é recomendando. 

WORKDIR /app # navega para a pasta /app

COPY . . # copia tudo o que tem na pasta em que está o Dockerfile para a pasta atual do workdir (que é /app)

CMD ["node", "index.js"] # executa o comando "node index.js"


```

## Build da imagem
Para gerar a imagem a partir do Dockerfile, precisamos fazer o build, pra isso temos o comando `build`.

ex:
`docker build -t fhsbatista/docker-node-example:latest .`.
Acima, coloquei um namespace, que poderia ser o nome do usuário no dockerhub. E o latest seria a tag. No final precisamos indicar a localizacao do dockerfile, por isso o ".". Isso pode ser substituido pelo diretorio caso o dockerfile esteja num diretorio diferente.

Obs: antes do build ser feito, o docker irá baixar a imagem de cada layer que sua imagem precisa.

Obs2: A imagem, após gerada, fica apenas no seu computador. Para consultá-la, você pode usar o comando `docker images`.

## Rodando a imagem
Basta usar o comando `run`.

## ARG
É uma maneira de criar "variáveis" no Dockerfile.
Ex: Abaixo, veja que é usado o NODE_VERSION para definir a versão do node, em vez de usar `latest` hardcoded.

```
ARG NODE_VERSION=21.1.0
FROM NODE:${NODE_VERSION}
```

A grande vantagem de usar isso, é que esses args podem ser passados no momento de buildar a imagem.
Ex:
`docker build --build-arg NODE_VERSION=21.1.0 -t fhsbatista/docker-node-example:latest`

Importante: O ARG só está disponível no momento do build da imagem. Portanto, não dá pra usar esses valores em runtime.

## ENV
É parecido com ARG, porém, esse fica disponível em runtime. Por conta disso, pode ser usado como uma espécie de variável de ambiente que a aplicação pode consumir enquanto é executada. Ex: definir o número da porta em que a aplicação rodará.

```
#Dockerfile
ENV PORT=3001
ENV MESSAGE="Hello docker"

#index.js
const port = process.env.PORT || 3000;

const message = process.env.MESSAGE || "HELLO WORLD!";

app.listen(port, () => {
  console.log(`Server is running on port ${port}`);
})
```

Essas ENV podem ser passadas ao criar e executar um container.
Ex:
`docker run -p 3001:3001 -e MESSAGE="Hello Friend" fhsbatista/docker-node-example`


## Segurança e usuários não root
### Usuário padrão do container
No ambiente de produção é muito importante não deixarmos o usuário root como o padrao do container. Para evitar isso, podemos configurar um novo usuário no Dockerfile e ativar esse usuário como o padrao do container.

ex:
```
RUN useradd -m mynode #cria um novo usuário
USER mynode #coloca esse usuário como o padrao do container.
```

Dessa forma, quando abrirmos o bash, o usuário novo será usado. E assim, não vamos conseguir executar comandos como administrador.

Uma outra maneira de tirar o acesso do root, sem criar um novo usuário, é usar um id que define as permissoes.

ex:
```
USER 1001
```

Usando essa abordagem, o usuário usado ao executar o bash será o "I have no name".