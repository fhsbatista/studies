# Docker compose
É uma maneira declarativa de configurar containers, via yml.

É vantajoso, pois:
 - é uma maneira de documentar os componentes do sistema
 - evita repetição de comandos no terminal
 - maneira fácil de compartilhar um mesmo conjunto de containers, garatindo que sejam configurados sempre da mesma forma.

Essas configurações são feitas no arquivo `docker-compose.yml`.

Obs: `.yml` ou `.yaml`, tanto faz.

## Estrutura do arquivo
### Version
Antigamente era necessário informar a versão do docker-compose usado, pela tag `version`.

Atualmente isso não é mais necessário.

### `services`
É onde declaramos os containers. Cada `service` seria um container.

### `image`
O mínimo necessário no service, é informar a imagem através da tag `image`.

Ex:
```yml
services:
    nginx:
        image: nginx:latest
```

### `ports`

Onde vamos publicar as portas. Equivalente ao parametro `p` ao usar o `docker run`

```yml
services:
    nginx:
        image: nginx:latest
        ports:
         - "1256:80"
```

### `volumes`
Onde vamos configurar "volumes" e "bind mounts"

Estrutura:

`<dir da pasta no host>:<dir da pasta no container>`

```yml
services:
    nginx:
        image: nginx:latest
        volumes:
         - ./nginx-html:/user/share/nginx/html
```

#### Volume vs Bind mount
Para configurar como "bind mount", o diretório da pasta no host deve ter o "./" no início.

Para configurar "volume", é só NÃO usar o "./"

### `build`
Aqui informamos um Dockerfile para fazer o build, em vez de especificar o nome da imagem já buildada.

Isso é útil quando queremos que fazer o build sempre antes de rodar o container.

```yml
services:
    node-app:
        build: .
```

Veja que nesse caso, não informamos `image`, já que a imagem será buildada.


#### ⚠️ Nem sempre o build é feito!!!
O `docker compose` só irá fazer o build da imagem se ele identificar que houve alguma alteração que justifique o build. Porém, as vezes ele não consegui identificar alterações e então precisamos de uma forma de forçar o build.

Isso é resolvido com o parâmetro `--build`.

Ex:
`docker compose up -d --build`.

Ou também, basta remover o container antes de subir de novo. Pra isso usamos o comando `down` já descrito anteriormente.

#### `context` e `dockerfile`
Dentro de `build`, podemos informar pelo `context` qual é o diretório que contém os arquivos necessários para o build.

E com o parametro `dockerfile`,  especificamos qual o arquivo dockerfile que deve gerar o build. Esse é útil quando queremos por exemplos ter vários dockerfiles para ambientes diferentes, como produção, debug etc.

Ex:

```yml
node:
    build:
      context: ./node-network
      dockerfile: Dockerfile
```

Acima por exemplo, o que está acontecendo é:
    - O docker compose vai buscar o arquivo `Dockerfile` dentro do context, que é `./node-network`.

#### `depends on`
Em alguns casos, para que um container rode ele precise que um outro esteja rodando antes.

Por exemplo, na pasta 9.docker-compose, temos a aplicação `node-network`. Nela temos um mongo e uma aplicação node.

A aplicação node, precisa que o mongo esteja rodando pra que ela rode corretamente. Então o mongo precisa ser iniciado antes da aplicação node.

No docker-compose, podemos fazer essa configuração de sequência usando o parâmetro `depends on`. Basta colocar ele no container que depende de outros, informando qual container é a dependência.

Ex:

```yml
  node:
    build:
      context: ./node-network
      dockerfile: Dockerfile
    depends_on:
      - mongo
    volumes:
      - ./node-network:/app
```

##### Atenção
O `depends on` cuida apenas da ordem de execução. Mesmo configurando a ordem, é necessário atenção pois ainda sim um container que depende de outro pode falhar, pois esse outro container, apesar de ter sido iniciado antes, pode ainda não estar pronto para receber requisições.

##### `condition`
Podemos configurar uma "condição" de estado que uma dependência tem que estar para que a execução dos containers continue.

Por exemplo, usando o caso do mongo acima, podemos dizer que o `node` depende do `mongo` no estado `healthchecking`. Do contrário, `node` não deve ser inicializado.

Ex:
```yml
  node:
    build:
      context: ./node-network
      dockerfile: Dockerfile
    depends_on:
      mongo:
        condition: service_healthy
    volumes:
      - ./node-network:/app
```

## Comandos
### Rodar containers
`docker compose up`

Esse comando vai criar e iniciar os containers.

Obs: Também será criada uma rede para esses containers, então eles irão conseguir se comunicar entre si.

#### Parametros
 - `d` : "dettached" -> usando esse parâmetro, o terminal não fica preso no log do container.

### Remover container
`docker compose down`

-> Esse vai parar e remover todos os containers do `docker-compose.yml`.

#### Removendo um container específico
Basta usar o comando `down` junto com o nome do container.

Ex:
`docker compose down mongo`


### `docker compose`
Se estamos dentro da pasta raíz do arquivo docker-compose, podemos usar o comando `docker compose` em vez de `docker`. Isso é interessante pois assim não precisamos usar o nome do container diretamente, mas sim o nome do serviço. O que é mais simples pois o nome do container criado pelo docker-compose normalmente pode vir com um número junto que não saberemos qual é, então fica um pouco inconveniente usar  nome do container.

Além disso, com o `docker compose`, os comandos ficam no contexto daquele `docker-compose.yml`, então, comandos como `ps` para listar os containers ativos, vão mostrar somentes os containers daquele `docker-compose.yml` específico.

