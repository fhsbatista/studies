# Spring Data

## @Repository vs @Component
`@Repository` é um estereótipo especializado para a camada de persistência; `@Component` é genérico.
Além da semântica, `@Repository` ativa a exception translation, convertendo exceções JPA/Hibernate na hierarquia `DataAccessException` do Spring.
Repositórios do Spring Data (como `JpaRepository`) já recebem esse comportamento automaticamente, sem anotar explicitamente.
Isso padroniza erros de dados entre provedores e simplifica tratamento, logs e testes.
Use `@Repository` para classes de acesso a dados e `@Component` para componentes genéricos.

## Spring Data JPA
Permite criar repositórios de forma declarativa. Criamos uma interface que estende `JpaRepository<Entidade, ID>` e o Spring Data JPA implementa tudo em runtime.

```java
@Repository
public interface CuisineRepository extends JpaRepository<Cuisine, Long> {
}
```

Métodos básicos como `save`, `findById`, `findAll`, `delete`, `existsById`, `count` já são implementados automaticamente — não precisamos declará-los na interface.

Query methods personalizados são derivados do nome: `findByNome`, `findByEmailAndAtivo`, `deleteByStatus`, etc. O framework analisa o nome e gera a consulta automaticamente.

```java
@Repository
public interface RestaurantRepository extends JpaRepository<Restaurant, Long> {
    List<Restaurant> findByName(String name);
    List<Restaurant> findByNameContaining(String name);
    Optional<Restaurant> findByNameAndCity(String name, String city);
    List<Restaurant> findByCuisineId(Long cuisineId);
    boolean existsByName(String name);
}
```

**Hierarquia de interfaces:**
No mercado é padrão estender `JpaRepository`, mas existem outras opções dependendo da necessidade:
- `CrudRepository`: métodos CRUD básicos (`save`, `findById`, `findAll`, `delete`, `count`, etc.)
- `PagingAndSortingRepository`: adiciona paginação e ordenação sobre o `CrudRepository`
- `JpaRepository`: adiciona operações específicas do JPA (batch, flush, getOne) sobre o `PagingAndSortingRepository`

Se sua entidade não precisa de paginação ou recursos JPA específicos, você pode estender diretamente `CrudRepository`.

**Recursos adicionais:**
- **@Query**: queries JPQL/SQL customizadas quando query methods não bastam (`@Query("SELECT u FROM Usuario u WHERE u.email = :email")`)
- **Paginação e ordenação**: `Pageable` e `Sort` como parâmetros (`findAll(Pageable)`, `findByStatus(Status, Sort)`)
- **Specifications**: queries dinâmicas com Criteria API para filtros complexos (`JpaSpecificationExecutor`)
- **Projeções**: retornar apenas campos específicos (interfaces ou DTOs) em vez da entidade completa
- **Auditing**: metadados automáticos com `@CreatedDate`, `@LastModifiedDate`, `@CreatedBy`, `@LastModifiedBy` (habilitar com `@EnableJpaAuditing`)

## Queries personalizadas
Exemplos
```java
@Repository
public interface CuisineRepository extends JpaRepository<Cuisine, Long> {
    List<Cuisine> findByName(String name);
    List<Cuisine> findByNameContaining(String name);
}

@Repository
public interface RestaurantRepository extends JpaRepository<Restaurant, Long> {
    List<Restaurant> findByDeliveryTaxBetween(BigDecimal minTax, BigDecimal maxTax);
    List<Restaurant> findByNameContainingAndDeliveryTaxBetween(String name, BigDecimal minTax, BigDecimal maxTax);
}
```

Conseguimos criar queries personalizas usando keywords específicas no nome dos métodos. Por exemplo o `find` vai fazer um select. Quando combinamos o `find` com `Containing`, será feito um select com uma clausula `where` que usa o `like` em vez de `=`.

Nesse link tem mais exemplos de keywords que podemos usar: https://docs.spring.io/spring-data/jpa/docs/current-SNAPSHOT/reference/html/#jpa.query-methods.query-creation