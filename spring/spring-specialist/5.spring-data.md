# Spring Data

## @Repository vs @Component
`@Repository` é um estereótipo especializado para a camada de persistência; `@Component` é genérico.
Além da semântica, `@Repository` ativa a exception translation, convertendo exceções JPA/Hibernate na hierarquia `DataAccessException` do Spring.
Repositórios do Spring Data (como `JpaRepository`) já recebem esse comportamento automaticamente, sem anotar explicitamente.
Isso padroniza erros de dados entre provedores e simplifica tratamento, logs e testes.
Use `@Repository` para classes de acesso a dados e `@Component` para componentes genéricos.

## Spring Data JPA
Permite criar repositórios de forma declarativa. Criamos uma interface que estende `JpaRepository<Entidade, ID>` e o Spring Data JPA implementa tudo em runtime.

```java
@Repository
public interface CuisineRepository extends JpaRepository<Cuisine, Long> {
}
```

Métodos básicos como `save`, `findById`, `findAll`, `delete`, `existsById`, `count` já são implementados automaticamente — não precisamos declará-los na interface.

Query methods personalizados são derivados do nome: `findByNome`, `findByEmailAndAtivo`, `deleteByStatus`, etc. O framework analisa o nome e gera a consulta automaticamente.

```java
@Repository
public interface RestaurantRepository extends JpaRepository<Restaurant, Long> {
    List<Restaurant> findByName(String name);
    List<Restaurant> findByNameContaining(String name);
    Optional<Restaurant> findByNameAndCity(String name, String city);
    List<Restaurant> findByCuisineId(Long cuisineId);
    boolean existsByName(String name);
}
```

**Hierarquia de interfaces:**
No mercado é padrão estender `JpaRepository`, mas existem outras opções dependendo da necessidade:
- `CrudRepository`: métodos CRUD básicos (`save`, `findById`, `findAll`, `delete`, `count`, etc.)
- `PagingAndSortingRepository`: adiciona paginação e ordenação sobre o `CrudRepository`
- `JpaRepository`: adiciona operações específicas do JPA (batch, flush, getOne) sobre o `PagingAndSortingRepository`

Se sua entidade não precisa de paginação ou recursos JPA específicos, você pode estender diretamente `CrudRepository`.

**Recursos adicionais:**
- **@Query**: queries JPQL/SQL customizadas quando query methods não bastam (`@Query("SELECT u FROM Usuario u WHERE u.email = :email")`)
- **Paginação e ordenação**: `Pageable` e `Sort` como parâmetros (`findAll(Pageable)`, `findByStatus(Status, Sort)`)
- **Specifications**: queries dinâmicas com Criteria API para filtros complexos (`JpaSpecificationExecutor`)
- **Projeções**: retornar apenas campos específicos (interfaces ou DTOs) em vez da entidade completa
- **Auditing**: metadados automáticos com `@CreatedDate`, `@LastModifiedDate`, `@CreatedBy`, `@LastModifiedBy` (habilitar com `@EnableJpaAuditing`)

## Queries personalizadas
Exemplos
```java
@Repository
public interface CuisineRepository extends JpaRepository<Cuisine, Long> {
    List<Cuisine> findByName(String name);
    List<Cuisine> findByNameContaining(String name);
}

@Repository
public interface RestaurantRepository extends JpaRepository<Restaurant, Long> {
    List<Restaurant> findByDeliveryTaxBetween(BigDecimal minTax, BigDecimal maxTax);
    List<Restaurant> findByNameContainingAndDeliveryTaxBetween(String name, BigDecimal minTax, BigDecimal maxTax);
}
```

Conseguimos criar queries personalizas usando keywords específicas no nome dos métodos. Por exemplo o `find` vai fazer um select. Quando combinamos o `find` com `Containing`, será feito um select com uma clausula `where` que usa o `like` em vez de `=`.

Prefixos como `find`, `get`, `query`, `read`, `search` funcionam da mesma forma — escolha o que soar melhor; o Spring trata todos como aliases para consultas.

Nesse link tem mais exemplos de keywords que podemos usar: https://docs.spring.io/spring-data/jpa/docs/current-SNAPSHOT/reference/html/#jpa.query-methods.query-creation

## Prefixos
- `existsBy`: retorna `boolean` indicando existência (`existsByEmail`)
- `countBy`: retorna quantidade que atende ao critério (`countByStatus`)
- `top` / `first`: limita o número de registros retornados (`findTop5ByNameContaining`)
- `find`, `get`, `query`, `read`, `search`: prefixos equivalentes para buscas
- Combine com filtros para comportamentos específicos, ex.: `findFirstByOrderByCreatedAtDesc()`, `countByActiveTrue()`

```java
@Repository
public interface OrderRepository extends JpaRepository<Order, Long> {
    boolean existsByCode(String code);
    long countByStatus(OrderStatus status);
    Optional<Order> findTopByCustomerIdOrderByCreatedAtDesc(Long customerId);
    List<Order> findFirst3ByActiveTrueOrderByCreatedAtAsc();
    List<Order> searchByDescriptionContaining(String term);
}
```

## Queries com JPQL personalizado
Quando não queremos montar a query combinando keywords (e podemos querer isso por vários motivos, como por o nome do método ficar muito grande ou até mesmo porque as keywords são insuficientes para a query que precisamos) podemos usar um JPQL personalizado. Isso traz muito mais flexibilidade e elimina a necessidade de um método com nome muito grande

Ex:

```java
@Query("from Restaurant where cuisine.id = :cuisineId and name like %:restaurantName%")
List<Restaurant> findInCuisinesByName(@Param("cuisineId") Long cuisineId, @Param("restaurantName") String restaurantName);
```

`@Query` permite definir manualmente a cláusula JPQL que será executada para aquele método. Repare que usamos o nome da entidade (`Restaurant`) e seus atributos (`cuisine.id`, `name`) — não o nome da tabela ou colunas físicas.

`@Param` vincula os placeholders nomeados da query (`:cuisineId`, `:restaurantName`) aos parâmetros do método, evitando depender da posição dos argumentos e tornando o código mais legível.

### Queries em xml
Para evitar poluir o código do repositório quando as queries são muito grandes, temos a opção de colar essa query num arquivo xml em resources/META-INF/orm.xml.

Obs: esse arquivo não vem criado por padrão, então se ele não existe, você precisa criá-lo.

Ex:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<entity-mappings
        xmlns="http://xmlns.jcp.org/xml/ns/persistence/orm"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/orm_2_2.xsd"
        version="2.2">
    
    <named-query name="Restaurant.findInCuisinesByName">
        <query>
            from Restaurant where cuisine.id = :cuisineId and name like concat('%', :restaurantName, '%')
        </query>
    </named-query>

</entity-mappings>
```

## Implementações customizadas (Custom Repository Implementation)
Mesmo estendendo `JpaRepository`, podemos fornecer implementações próprias para métodos complexos. A técnica oficial do Spring Data é criar uma interface auxiliar (ex.: `RestaurantRepositoryQueries`) e fazer o repositório principal estender `JpaRepository` + essa interface; então fornecemos uma classe `RestaurantRepositoryImpl` (nome da interface + `Impl`) contendo a lógica manual.

```java
public interface RestaurantRepositoryQueries {
    List<Restaurant> findAll(String name,
                             BigDecimal initialDeliveryTax,
                             BigDecimal finalDeliveryTax);
}

public interface RestaurantRepository extends JpaRepository<Restaurant, Long>,
        RestaurantRepositoryQueries {
}

@Repository
public class RestaurantRepositoryImpl implements RestaurantRepositoryQueries {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public List<Restaurant> findAll(String name,
                                    BigDecimal initialDeliveryTax,
                                    BigDecimal finalDeliveryTax) {
        final var jpql = """
            from Restaurant
            where name like :name
              and deliveryTax between :initialDeliveryTax and :finalDeliveryTax
        """;

        return entityManager.createQuery(jpql, Restaurant.class)
                .setParameter("name", "%" + name + "%")
                .setParameter("initialDeliveryTax", initialDeliveryTax)
                .setParameter("finalDeliveryTax", finalDeliveryTax)
                .getResultList();
    }
}
```

Use essa abordagem quando a consulta/comando é sofisticado demais para expressar no nome do método ou em um `@Query`, mas você ainda quer todos os recursos do `JpaRepository`.

## Criteria API
Criteria API permite construir queries JPQL de forma programática e type-safe, ideal para consultas dinâmicas onde os filtros variam conforme parâmetros opcionais. Em vez de concatenar strings JPQL, você monta a query usando objetos Java.

Ex:
```java
public List<Restaurant> criteriaApiFindAll(String name, 
                                          BigDecimal initialDeliveryTax, 
                                          BigDecimal finalDeliveryTax) {
    final var criteriaBuilder = entityManager.getCriteriaBuilder();
    final var criteriaQuery = criteriaBuilder.createQuery(Restaurant.class);
    final var root = criteriaQuery.from(Restaurant.class);
    final var predicates = new ArrayList<Predicate>();
    
    if (StringUtils.hasText(name)) {
        predicates.add(criteriaBuilder.like(root.get("name"), "%" + name + "%"));
    }
    if (initialDeliveryTax != null) {
        predicates.add(criteriaBuilder.greaterThanOrEqualTo(root.get("deliveryTax"), initialDeliveryTax));
    }
    if (finalDeliveryTax != null) {
        predicates.add(criteriaBuilder.lessThanOrEqualTo(root.get("deliveryTax"), finalDeliveryTax));
    }
    
    criteriaQuery.where(predicates.toArray(new Predicate[0])); // Converte ArrayList para var args
    
    return entityManager.createQuery(criteriaQuery).getResultList();
}
```

**CriteriaBuilder**: fábrica para criar queries, predicados e expressões. Fornece métodos como `like()`, `greaterThanOrEqualTo()`, `lessThanOrEqualTo()` para montar condições.

**CriteriaQuery**: representa a query sendo construída. Define a entidade raiz (`from`), condições (`where`), ordenação (`orderBy`), etc.

**Root**: representa a entidade principal da query (no exemplo, `Restaurant`). É o ponto de partida para acessar atributos (`root.get("name")`) e construir predicados. Fundamental para referenciar campos da entidade de forma type-safe.

**Predicates**: condições da cláusula `WHERE`. Cada predicado é uma expressão booleana (ex.: `name LIKE '%valor%'`). Podem ser combinados com `and()`, `or()`, `not()` para formar filtros complexos.