# Resiliência
Esse é um tema muito importante em arquitetura de microsserviços.

Precisamos ter a seguinte premissa:
"Todo serviço, eventualmente vai falhar".

Por conta disso, precisamos ter planos para mitigar essas falhas de maneira a afetar o sistema todo o mínimo possível.

O que é resiliência:
> É a capacidade de se adaptar ao ambiente em vez de quebrar.

Queremos tomar iniciativas deliberadas, intencionais, de mapear os pontos de falhas do sistema e maneiras de mitigar as falhas quando acontecerem.

## Estrtégias

### Proteger e ser protegido
#### Serviço se auto protegendo
Precisamos fazer com que o sistema se auto preserve a fim de garantir ao máximo a "qualidade".
Com "qualidade", queremos dizer:
 - Algo bem feito
 - Algo que tem sempre o mesmo comportamento independente de fatores externos

Analogia cerveja:
 - Uma cerveja mesmo sendo muito gostosa, não tem "qualidade" se o gosto dela muda a cada gole.
 - Ou seja, além de ser bom, o comportamento deve ser uniforme.

Na ideia de microservices, o que buscamos é que o sistema mantenha o comportamento independente do ambiente. Por exemplo, queremos que ele responda da mesma maneira, não importa se temos 1 requisição por segundo ou 1 milhão.

Para atingir isso, precisamos cuidar da auto preservação.

Um exemplo disso é:
 - um sistema precisa responder em até 500ms
 - então vamos projetar o sistema para que responda nesse tempo, não importa se temos 1 requisição por segundo ou 1 milhão
 - para atingir isso, podemos por exemplo":
    - se o sistema só consegue responder 1 mil requisições por segundo, vamos barrar o restante para garantir o SLA de 500ms. Para as outras requisições, vamos pensar em outra estratégia.

#### Protegendo os outros serviços
Um serviço deve cuidar dos outros, não ser "egoísta", ajudando os outros serviços a se manterem de pé.
Fazemos isso não tentando chamar um serviço indefinidamente se está dando falhando. Devemos adotar estratégias para aguardar um pouco e esperar o serviço voltar ao ar.

Se um serviço está falhando, e um outro fica chamando ele, recebendo timeout e dando retry, basicamenteo o segundo sistema está "enterrando" o primeiro, "chutando cachorro morto".

> Um sistema lento no ar, pode ser pior do que um sistema fora do ar. Pois um sistema lento pode causar vários efeitos colaterais em outros serviços, deixando todo o sistema lento. Ou seja, um serviço retornar um 500 pode ser melhor do que um responder num tempo muito grande.

### Health check
É necessário termos uma forma de chamar um serviço pra saber se ele está "saudável".

Isso é diferente de só verificar se o sistema está "respondendo", ou seja, não é só verificar se o sistema tá de pé. É necessário que essa checagem verifique os componentes que o sistema depende, como banco de dados. 

#### Self healing
Um sistema que não está saudável, pode se recuperar se o tráfego parar ou diminuir temporariamente. Assim o sistema pode processar o que ficou emperrado, e voltar a ficar saudável quando terminar o processamento.

Veja que essa é uma estratégia melhor do que simplesmente matar o sistema e subir de novo, pois quando derrubamos o sistema pra subir de novo, nós perdemos as requisições que não foram processadas e vamos também perder as novas que chegaram no período em que o sistema estava subindo de novo.

Então, é interessante deixar o sistema apto a self healing a fim de não perder requisições.

#### Qualidade do health check
##### Health check passivo
É quando a checagem sabe a saúde somente quando alguém pergunta. Ou seja, o sistema pode estar morto, mas a checagem ainda não sabe. Ela só irá saber quando alguém perguntar.

##### Health check ativo
Quando o sistema fica se auto chamando, ou outro sistema exclusivo pra isso fica chamando o primeiro sistema, para verificar a saúde. Se verificar que não está ok, ele já pode chamar mecanismos de resiliência.

##### Nginx curiosidade
O free, tem healthcheck passivo. O pago, tem o ativo.

##### Probes do kubernetes
É uma ferramenta de health check ativo que o kubernetes fornece.

### Rate limiting