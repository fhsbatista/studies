# Resiliência
Esse é um tema muito importante em arquitetura de microsserviços.

Precisamos ter a seguinte premissa:
"Todo serviço, eventualmente vai falhar".

Por conta disso, precisamos ter planos para mitigar essas falhas de maneira a afetar o sistema todo o mínimo possível.

O que é resiliência:
> É a capacidade de se adaptar ao ambiente em vez de quebrar.

Queremos tomar iniciativas deliberadas, intencionais, de mapear os pontos de falhas do sistema e maneiras de mitigar as falhas quando acontecerem.

## Estrtégias

### Proteger e ser protegido
#### Serviço se auto protegendo
Precisamos fazer com que o sistema se auto preserve a fim de garantir ao máximo a "qualidade".
Com "qualidade", queremos dizer:
 - Algo bem feito
 - Algo que tem sempre o mesmo comportamento independente de fatores externos

Analogia cerveja:
 - Uma cerveja mesmo sendo muito gostosa, não tem "qualidade" se o gosto dela muda a cada gole.
 - Ou seja, além de ser bom, o comportamento deve ser uniforme.

Na ideia de microservices, o que buscamos é que o sistema mantenha o comportamento independente do ambiente. Por exemplo, queremos que ele responda da mesma maneira, não importa se temos 1 requisição por segundo ou 1 milhão.

Para atingir isso, precisamos cuidar da auto preservação.

Um exemplo disso é:
 - um sistema precisa responder em até 500ms
 - então vamos projetar o sistema para que responda nesse tempo, não importa se temos 1 requisição por segundo ou 1 milhão
 - para atingir isso, podemos por exemplo":
    - se o sistema só consegue responder 1 mil requisições por segundo, vamos barrar o restante para garantir o SLA de 500ms. Para as outras requisições, vamos pensar em outra estratégia.

#### Protegendo os outros serviços
Um serviço deve cuidar dos outros, não ser "egoísta", ajudando os outros serviços a se manterem de pé.
Fazemos isso não tentando chamar um serviço indefinidamente se está dando falhando. Devemos adotar estratégias para aguardar um pouco e esperar o serviço voltar ao ar.

Se um serviço está falhando, e um outro fica chamando ele, recebendo timeout e dando retry, basicamenteo o segundo sistema está "enterrando" o primeiro, "chutando cachorro morto".

> Um sistema lento no ar, pode ser pior do que um sistema fora do ar. Pois um sistema lento pode causar vários efeitos colaterais em outros serviços, deixando todo o sistema lento. Ou seja, um serviço retornar um 500 pode ser melhor do que um responder num tempo muito grande.

### Health check
É necessário termos uma forma de chamar um serviço pra saber se ele está "saudável".

Isso é diferente de só verificar se o sistema está "respondendo", ou seja, não é só verificar se o sistema tá de pé. É necessário que essa checagem verifique os componentes que o sistema depende, como banco de dados. 

#### Self healing
Um sistema que não está saudável, pode se recuperar se o tráfego parar ou diminuir temporariamente. Assim o sistema pode processar o que ficou emperrado, e voltar a ficar saudável quando terminar o processamento.

Veja que essa é uma estratégia melhor do que simplesmente matar o sistema e subir de novo, pois quando derrubamos o sistema pra subir de novo, nós perdemos as requisições que não foram processadas e vamos também perder as novas que chegaram no período em que o sistema estava subindo de novo.

Então, é interessante deixar o sistema apto a self healing a fim de não perder requisições.

#### Qualidade do health check
##### Health check passivo
É quando a checagem sabe a saúde somente quando alguém pergunta. Ou seja, o sistema pode estar morto, mas a checagem ainda não sabe. Ela só irá saber quando alguém perguntar.

##### Health check ativo
Quando o sistema fica se auto chamando, ou outro sistema exclusivo pra isso fica chamando o primeiro sistema, para verificar a saúde. Se verificar que não está ok, ele já pode chamar mecanismos de resiliência.

##### Nginx curiosidade
O free, tem healthcheck passivo. O pago, tem o ativo.

##### Probes do kubernetes
É uma ferramenta de health check ativo que o kubernetes fornece.

### Rate limiting
#### Proteção do sistema
Podemos limitar a quantidade de requisições que chegam no sistema para garantir a qualidade. Por exemplo, se o sistema só consegue garantir a qualidade quando está recebendo no máximo mil requisições por segundo, podemos limitar em mil por segundo, assim o sistema não recebe mais requisições do que ele consegue suportar.

#### Preferências por cliente
Em alguns casos, podemos ter um cliente do sistema que é muito mais importante que os outros. Nesse caso, pode não ser interessante esse cliente ter a mesma limitação que outros, que tem menor ou talvez nenhuma importancia.

Ex: 
 - Temos 10 clientes, e o sistema atende com qualidade somente 1k rps.
 - 1 desses clientes, representa 90% do faturamento.
 - Se aplicarmos o rate limiting padrão, e todos os clientes usam o sistema na mesma proporção, cada cliente conseguiria enviar 100 rps apenas.
 - Nesse caso, como um cliente é extremamente mais importante que os outros, pode ser interessante dar uma preferência à ele. E os clientes menos importante estão tendo uma preferência maior.

Pra resolver essa preferência podemos criar regras no rate limiting de acordo com o cliente.

Normalmente, isso é o correto a ser feito. Aplicar um rate limiting padrão sem essa personalização pode ser nada interessante.

Obs: veja que essa parte não envolve apenas tecnlogia, mas também a área de negócios pra entender qual estratégia adotar pra cada cliente.

### Circuit breaker
Uma maneira de proteger o sistema, fazendo com que as requisições que cheguem a ele sejam negadas.

Obs: circuit breaker é um "disjuntor".

circuito fechado = requisições chegam ao sistema
circuito aberto = requisições param de chegar
circuito meio aberto (half open) = permite uma quantidade limitada, pra verificar se o sistema tem condições de voltar à normalidade.

#### Decisões
Normalmente quem implementa isso é a pessoa que desenvolve. Isso demanda bastante tempo normalmente, e acaba ficando nelas a decisão de quantas requisições usar no half open, escolhem quando abrir ou fechar o circuito etc. O problema é que normalmente essa pessoa tem acesso à apenas um ou alguns microsserviços. Ou seja, essa pessoa talvez não tenha todo o contexto necessário pra tomar a melhor decisão.

Pra evitar que a pessoa que desenvolve precise tomar essas decisões, temos algumas ferramentas como o service mesh e API gateway, e então isso fica a cargo de pessoas com maior capacidade de tomar essas decisões.