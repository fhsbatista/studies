# Patterns
Ao trabalhar com microsserviços temos problemas que não existem nos sistemas monolíticos. Para lidar com esses problemas, existem diversos padrões.

## Api Composition
Exemplo de problema:
 - contexto: Geração de relátorios
 - Um frontend, Serviço A e serviço B
 - Pra gerar o relatório
    - frontend chama serviço A
    - chama o serviço B
    - junta os dados e gera o relatório

![](images/patterns/frontend-reports.png)

Nesse exemplo, nosso problema tá resolvido.

Mas e se em vez de um frontend, temos um outro service como client que chama os outros serviços, junta os dados e gera o relatório?

![](images/patterns/service-reports.png)

Nos dois casos acima, temos exemplos de API Composition (composer), pois temos um componente (o frontend ou o serviço no segundo exemplo) que são responsáveis por chamar os outros serviços, juntar os dados e gerar o relatório.

De maneira mais elaborada, esse padrão é quando nós fazemos com que os clientes do serviços sejam responsáveis por chamar os serviços na ordem correta e combinar os dados gerados por eles. É o padrão mais simples que temos e um dos mais importantes.

### Vantagens
Fica centralizado em um único lugar a responsabilidade de buscar e combinar os dados, e os serviços não precisam lidar com isso, não criando acoplamento entre eles.

### Desvantagens
 - Problema de disponibilidade: Se um dos serviços cair, o composer basicamente cai também.
 - Consistência nos dados: pode ser que ao terminar de chamar todos os serviços, os dados gerador pelos primeiros serviços já estejam desatualizados.
 - Aumento de complexidade pois adicionamos um componente somente pra compor esses dados.
 - Temos um serviço criado com o objeto só de chamar outros serviços.
 - Alta latência pois por baixo dos panos vários serviços estão sendo chamados.

### Resiliência
Como o composer vai fazer operações ou gerar dados a partir de outros services, é precisa pensar no que fazer caso algum deles falhe ou esteja indisponível.
Num relatório, por exemplo, temos a opção de colocar as informações referentes a um serviço que falou de maneira reduzida.

## Decompose by business capability
Esse é um padrão que vai ajudar a iniciar migração de um monolito para uma distrubuir em microsserviços.

### Exemplo prático
Um sistema monolítico com áreas de:
 - Financeiro
 - CRM
 - Compras
 - Clientes

Um monolito desse tipo, poderíamos inicialmente gerar um serviço para cada uma dessas áreas.
O grande dificultadr, é que normalmente, a relação entre áreas do monilitos e microsserviços não serão 1 : 1.

Por exemplo, o módulo financeiro pode ter ligações com a área de clientes e CRM, gerando áreas cinzentas. Esses casos que vão gerar mais dificuldade na separação.

Uma maneira de diminuir essas áreas cinzentas é usando o DDD.

### DDD
Com ele, vamos conseguir elencar o que faz parte do **core**  e os **subdomínios** do sistema, assim deixando mais claro como dividir os microsserviços.

### Resumo
Um dos principais pontos é entender que, embora o monolito já esteja separado em contextos, módulos etc, essas separações dificilmente vão funcionar como microsserviços. Existem intersecções entre esses módulos que precisam ser entendidas pra conseguir fazer a decomposição.

## Strangler application
Esse é um padrao que pode ser usado na transição de monolito para microsserviços.

Com ele, vamos definir algumas regras para novas features no sistema.

1 - Toda nova feature será feita como microsserviço
2 - Pegar pequenos pedaços do sistema monolítico e transformar em microsserviço.

Dessa forma, vamos diminuindo o monolito aos poucos, e com o passar do tempo, o monolito não estará mais fazendo nada, por isso o nome "strangler", é como se estivéssemos estrangulando o monolito aos poucos até que ele morra.

### Pontos de atenção
#### Comunicação
Um dos primeiros problemas que irá surgir é a comunicação com o monolito. Pra isso provavelmente será necessário colocar novas ferramentas, como para eventos por exemplo, que ainda não são usadas, aumento o atrito para começar essa migração.

#### Maturidade da equipe
É necessário que a equipe já esteja preparada para coisas como automação, cobertura de testes etc. Sem essas coisas é inviável trabalhar com microsserviços, e então, relembrando coisas anotadas anteriormente, se a equipe não possui essa maturidade, trabalhar com microsserviços não é uma opção.

#### Banco de dados
A ideia é que cada microsserviço tenha seu próprio banco de dados. Mas para esse momento de transição, é comum que se use um banco compartilhado para esses serviços e isso vai sendo migrado para o banco específico do serviço.

Para auxiliar nessa migração, o que se pode fazer é migrar para o novo banco do serviço somente os dados que ele realmente usa.

O uso de APM também pode ajudar com as métricas que mostram o uso do banco, quais tabelas sao mais lidas, quais tem mais escrita etc. Isso pode dar insights de como fazer a migração.

#### APM
O correto é que cada serviço tenha seu próprio APM. Isso é obrigatório pra conseguir acomapanhar a saúde do serviço.

#### Métricas
É interessante definir métricas esperadas para os novos serviços e configurar alarmes, para garantir que anormalidades serão mitigadas o quanto antes.
