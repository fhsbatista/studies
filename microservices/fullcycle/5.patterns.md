# Patterns
Ao trabalhar com microsserviços temos problemas que não existem nos sistemas monolíticos. Para lidar com esses problemas, existem diversos padrões.

## Api Composition
Exemplo de problema:
 - contexto: Geração de relátorios
 - Um frontend, Serviço A e serviço B
 - Pra gerar o relatório
    - frontend chama serviço A
    - chama o serviço B
    - junta os dados e gera o relatório

![](images/patterns/frontend-reports.png)

Nesse exemplo, nosso problema tá resolvido.

Mas e se em vez de um frontend, temos um outro service como client que chama os outros serviços, junta os dados e gera o relatório?

![](images/patterns/service-reports.png)

Nos dois casos acima, temos exemplos de API Composition (composer), pois temos um componente (o frontend ou o serviço no segundo exemplo) que são responsáveis por chamar os outros serviços, juntar os dados e gerar o relatório.

De maneira mais elaborada, esse padrão é quando nós fazemos com que os clientes do serviços sejam responsáveis por chamar os serviços na ordem correta e combinar os dados gerados por eles. É o padrão mais simples que temos e um dos mais importantes.

### Vantagens
Fica centralizado em um único lugar a responsabilidade de buscar e combinar os dados, e os serviços não precisam lidar com isso, não criando acoplamento entre eles.

### Desvantagens
 - Problema de disponibilidade: Se um dos serviços cair, o composer basicamente cai também.
 - Consistência nos dados: pode ser que ao terminar de chamar todos os serviços, os dados gerador pelos primeiros serviços já estejam desatualizados.
 - Aumento de complexidade pois adicionamos um componente somente pra compor esses dados.
 - Temos um serviço criado com o objeto só de chamar outros serviços.
 - Alta latência pois por baixo dos panos vários serviços estão sendo chamados.

### Resiliência
Como o composer vai fazer operações ou gerar dados a partir de outros services, é precisa pensar no que fazer caso algum deles falhe ou esteja indisponível.
Num relatório, por exemplo, temos a opção de colocar as informações referentes a um serviço que falou de maneira reduzida.

## Decompose by business capability
Esse é um padrão que vai ajudar a iniciar migração de um monolito para uma distrubuir em microsserviços.

### Exemplo prático
Um sistema monolítico com áreas de:
 - Financeiro
 - CRM
 - Compras
 - Clientes

Um monolito desse tipo, poderíamos inicialmente gerar um serviço para cada uma dessas áreas.
O grande dificultadr, é que normalmente, a relação entre áreas do monilitos e microsserviços não serão 1 : 1.

Por exemplo, o módulo financeiro pode ter ligações com a área de clientes e CRM, gerando áreas cinzentas. Esses casos que vão gerar mais dificuldade na separação.

Uma maneira de diminuir essas áreas cinzentas é usando o DDD.

### DDD
Com ele, vamos conseguir elencar o que faz parte do **core**  e os **subdomínios** do sistema, assim deixando mais claro como dividir os microsserviços.

### Resumo
Um dos principais pontos é entender que, embora o monolito já esteja separado em contextos, módulos etc, essas separações dificilmente vão funcionar como microsserviços. Existem intersecções entre esses módulos que precisam ser entendidas pra conseguir fazer a decomposição.

