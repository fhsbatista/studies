- temos 2 tipos de "gargalos" numa aplicacao: I/O bound e CPU bound.
- quando o maior gargalo da aplicacao é I/O em vez de CPU, não vale muito a pena estratégias como "mudar a linguagem de programação" pra tunar a aplicação.
- quando I/O é o gargalo, vale apena tentarmos otimizar a comunicação com banco de dados, escritas em disco etc.
- No caso de sistemas distribuídos, normalmente o gargalo é I/O.

transaction time de uma requisicao no banco de dados é composto por:
 - tempo pra adquirir a conexão +
 - tempo pra requisicao ser enviada ao banco +
 - tempo de execucao do comando + 
 - tempo de resposta do banco pro consumer +
 - tempo em que a transação fica "idle", que acontece enquanto a aplicacao processa a resposta do banco

 -> quanto menor esse transaction response time, maior o throughput.


## Melhorando o tempo de conexão com o banco
estratégias de criaçao de conexao com banco de dados:
 - é uma má ideia abrir uma conexao para cada requisicao que nossa aplicacao recebe
 - pois provavelmente, o número de requisições simultaneas pode ser maior que o número de conexões que o banco suporta
 - portanto, é legal que a gente tenha um componente no nível da aplicação que gerencia essas requisições, isso normlamente é chamado de connection pool. Isso traz vantagens:
    - compartilha uma conexão pra várias requisições
    - as conexões já podem estar previamente abertas, assim diminuindo o transaction time de acesso ao banco pois não será necessário abrir uma conexão
    - caso o número de conexões compartilhadas não seja o suficiente em algum momento, esse gerenciador pode criar mais
    - caso a demanda diminua, o gerenciador pode fechar conexões abertas que são desnecessárias

sobre connection pool:
 -  se vc tem problemas de performance com o banco, muito provavelmente vc nao vai resolver aumentar o número de conexões no pool. A causa mais provável provavelmente algo nada eficiente que está sendo feito. Como regra de ouro, diminua ou mantenha o pool com o mesmo número de conexões.

HikariCP é o pool mais famoso no mundo java atualmente. Ele é muito performático, sem abrir mão de segurança por race condition. No artigo https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing, tem um vídeo interessante mostrando uma aplicacao com 10k usuários simultaneos, em que foi diminuido o tempo de resposta do banco de 100ms pra 2ms, ao mesmo tempo que foi dimunuído de 2000 pra 100 o número de conexões no pool. Isso mostra que além de o número de conexoes não ser o problema, normalmente um número menor pode na verdade trazer mais perfomance.

Um número menor de conexões no pool pode melhorar a performance pois, quanto mais conexões abertas mais colocamos carga no banco, fazendo com que ele tenha várias threads concorrendo, gerando fila e aumentando o número de espera, aumentando a latência. Quando diminuimos o número de conexões, nós tiramos a carga do banco e colocamos na camada de aplicação, assim, o pool de conexões trabalha protegendo o banco.

Um bom framework de pensamento, é pensar que o banco de dados precisa ser cuidado, tirando dele quando possível qualquer carga pois sua performance é mais limitada, então o ideal é jogarmos essa carga onde temos mais performance, que normalmente será na aplicação.

## Melhorando o tempo de requisição
Requisição: envio do comando para o banco de dados
No mundo java, o hibernate começa a atuar nesse ponto, dando algumas ferramentas como configuração de tamanho do batch.

### Batch size
Se temos 1000 inserções (ou qualquer outro comando) pra fazer num banco, podemos fazer isso 1 por 1, gernado assim 1000 requisições. Cada requisição dessa, tem o tempo de chegar até o banco, ser processada, e ser respondida. Isso conta como um round trip. 

Existe uma maneira de otimizar esse tempo, fazendo com que tenhamos apenas um envio e uma resposta, que é agrupando todos os comandos em um "batch". Assim o comando é enviado apenas uma vez, e respondido apenas uma vez. Em resumo, diminuímos o número de round trips de 1000 pra 1 (seguindo o exemplo de 1000 inserções).

## Melhorando o tempo de resposta


